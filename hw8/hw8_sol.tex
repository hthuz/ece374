\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
%\usepackage{graphicx}
\usepackage{amsmath}

%% Presenet code
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}

% set HW number
\newcommand{\HWnum}{8}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu$^\ast$, 3200110457}
\newcommand{\StudentB}{Suhao Wang, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
  \textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header


% =============

\question{22.A}

Represent the underground tunnel system as a connected undirected graph $G = (V,E)$, where $V$ is the set of intersections of tunnels and $E$ is the set of tunnels. $n$ is size of $V$ and $m$ is size of $E$. To check if a tunnel $e$ is critical, simply check if $G' = (V,E - {e})$ is connected. Use depth first search to determine if $G'$ is connected takes linear time $O(n + m - 1)$.

\begin{lstlisting}
  def isCritical(G(V,E),e):
    T = Tree/Forest genearted by DFS((V, E - {e}))
    if T is a Forest(has multiple root nodes)
      return true
    return False
\end{lstlisting}


\question{22.B}

If tunnel $\{v_i, v_j\}$ is destroyed and cops can'n still find a way going from $v_i$ to $v_j$ or from $v_j$ to $V_i$, this shows that there is only one path from $v_i$ to $v_j$ or from $v_j$ to $v_i$, without forming cycles. On other words, $\{v_i, v_j\}$ is critical if it is not an edge of any cycle. To indentify every critical tunnel, do depth first search to find all vertices that are part of a cycle. Then get critical edge from vertices that are not part of any cycle.

\begin{lstlisting}
def FindCriticalTunnel(G(V,E)):
  T(V,E1) = Tree generated by DFS(G)
  CycleVertices = empty
  CriticalEdge = empty
  for edge({vi, vj}) in E - E1 do
    CycleVertices += vi,vj
  for vetex(vi) in V - CycleVertices:
    CriticalEdge += edges in Adj(vi)
  return CriticalEdge
\end{lstlisting}

DFS takes linear time and finding vertices in cycles as well as find critical edges takes linear time. So the total time complexity is $O(n + m)$.

\question{22.C}

The problem is equivalent to find all critical vertices $v$ such that $G' = (V - \{v\}, E - \mbox{\{edges in Adj(v)\}})$ are disconnected. Suppose vertex $v_i$ is removed and $v_i$ is in one cycle $v_1,v_2...v_i,v_{i+1}...v_1$. Then the rest of vertices are still connected using the edge in reverse order. So critical vertices are those that are in one path without forming a cycle. Use similar approach all critical vertices can be found.

\begin{lstlisting}
def FindCriticalIntersetion(G(V,E)):
  T(V,E1) = Tree generated by DFS(G)
  CycleVertices = empty
  CriticalVertices = empty
  for edge({vi, vj}) in E - E1 do
    CycleVertices += vi,vj
  for vetex(vi) in V - CycleVertices:
    for edge({vi,vj}) in Adj(vi)
    CriticalVertices += vi,vj
  return CriticalVertices
\end{lstlisting}

Note that even though some vertices participate in forming into one cycle, if it also participates in forming a non-cycle path, it is critical as well. Similarily, the time complexity is $O(n + m)$


\question{23.A}\\
1. Topological sorting
\\2. traverse vertex for topological sorting result:
\\If for any vertex $n$ except the last vertex in the list, there is an edge from $n$ to $n+1$, then G has a Hamiltonian path.
\\Otherwise, G doesn't have a Hamiltonian path.
\\3. Explanation: in Hamiltonian path you have to visit all the vertices. In the topological sorting result, you cannot "go back". So the only strategy is to "traverse in turn without skip". 
\begin{lstlisting}
TopSort(G):
	Sorted <- NULL
	deg_in[1....n] <- -1
	Tdeg_in[1...n] <- NULL
	for each edge xy in G do
		deg_in[y] ++
	for each vertex v in G do
		Tdeg_in[deg_in[v]].append(v)
	while (Tdeg_in[0] is non-empty) do
		Remove node x from Tdeg_in[0]
		Sorted.append(x)
		for each edge xy in Adj(x) do
			deg_in[y]--
			move y to Tdeg_in[deg_in[y]]
	Output Sorted
Hami(G):
	Sort_List = TopSort(G)
	for each vertex v in Sorted_List do  # except the last vertex
		have_edge = 0
		for each edge vu in Adj(v) do
			 if (u == vertex v successor): 
				have_edge = 1	
		if (have_edge == 0) do
			return False
	return True

\end{lstlisting}
topsort running time is O(V+E). Hami main function also just go through all the vertices and edges once. Running time is O(V+E).V is the vertex number, E is the edge number.\\

\question{23.B}\\
1. use topological sorting and traverse the vertices of the topological sorting result to realize dynamically programming.
\\2. For each vertex $x$, determine whether $avg\_weight[x]$ is equal to -1. 
\\If it is -1, then $s$ cannot reach the vertex. continue.
\\If it is not equal to -1, it means that $s$ can reach this vertex. Walk through each of its edges, and then update the maximum average weight of all the vertices connected by $x$.
\\3. $avg\_weight[t]$ will store the maximum weight from $s$ to $t$, if it is -1, then $t$ is not reachable for $s$.
\\($avg\_weight[t]$ is the maximum average weight from $s$ to $i$)
\begin{lstlisting}
TopSort(G):
	decribe in A
Avg(G, s, t):
	avg_weight[1.....n] <- -1
	edge_num[1.....n] <- 0
	Sort_List = TopSort(G)
	for each vertex x in Sort_List do
		if (x == s):
			avg_weight[x] = 0
			edge_num[x] = 0
		if (average_weight[x] != -1 ) do
			for each edge xy in Adj(x) do
				new_path = (avg_weight[x]*edge_num[x]+w(xy) )/(edge_num[x]+1)
				# w (xy) is the edge xy's weight
				avg_weight[y] = max{ avg_weight[y], new_path}
				if (new_path == avg_weight[y]) do
					edge_num[y]++
	Output avg_weight[t]
\end{lstlisting}
topsort running time is O(V+E). Avg main function also just go through all the vertices and edges once. Running time is O(V+E).V is the vertex number, E is the edge number.\\


\question{23.C}\\
1. use topological sorting and traverse the vertices of the topological sorting result to realize dynamically programming.
\\2. For each vertex $x$, determine whether $path\_weight[x]$ is equal to -1. 
\\If it is -1, then $s$ cannot reach the vertex. continue.
\\If it is not equal to -1, it means that $s$ can reach this vertex. Walk through each of its edges, and then update the maximum weight of all the vertices connected by $x$.
\\3. $path\_weight[t]$ will store the maximum weight from $s$ to $t$, if it is -1, then $t$ is not reachable for $s$.
\\($path\_weight[i]$ is the maximum weight from $s$ to $i$)
\begin{lstlisting}
TopSort(G):
	decribe in A
Spec(G, s, t):
	path_weight[1.....n] <- -1
	Sort_List = TopSort(G)
	for each vertex x in Sort_List do
		if (x == s):
			path_weight[x] = 0
		if ( path_weight[x] != -1 ) do
			for each edge xy in Adj(x) do
				path_weight[y] = max{ path_weight[y], path_weight[x]+w(y)}
				# w(y) means the weight of vertex y no matter it is special or not
	Output path_weight[t]
\end{lstlisting}
topsort running time is O(V+E). Spec main function also just go through all the vertices and edges once. Running time is O(V+E).V is the vertex number, E is the edge number.\\


\question{23.D}\\
1. First, the DAG is topologically sorted
\\2. The results sorted by topology will be dynamically programmed from front to back
\\(path[i] represents whether the number of different paths from s to vertex i is odd or even. 0 means even, 1 means odd.)
\\3. Start by setting all arrays for dynamic programming to -1,
\\4. Starting at the starting vertex s, set its $path$ to even (because there are zero paths).
\\5. Then all the edges of s are considered, and the vertices connected by s are updated according to $path[s]$. Use "path[y] = (path[y] + path[x]) mod 2" to get the "temporary" parity of the connected vertices.
\\6. Select the next node for topological sort and do the same thing, repeating the previous step until we reach node t.
\\(When we traverse to vertex j, it means that the number of paths for this node has been determined, that is, its parity has been determined)
\begin{lstlisting}
EVEN = 0 
ODD = 1
# (EVEN+ODD) mod 2=ODD, (EVEN+EVEN) mod 2=EVEN, ODD+ODD mod 2= EVEN, 
TopSort(G):
	# decribe in A
even_odd(G, s, t):
	path[1.....n] <- -1
	Sort_List = TopSort(G)
	for each vertex x in Sort_List do
		if (x == s):
			path[x] = EVEN
		if ( path[x] != -1 ) do
			for each edge xy in Adj(x) do
				if ( path[y] == -1 ) do
					path[y] = EVEN
				path[y]  = (path[y] + path[x]) mod 2
	Output path[t]
\end{lstlisting}
topsort running time is O(V+E). even\_odd main function also just go through all the vertices and edges once. Running time is O(V+E).V is the vertex number, E is the edge number.\\
\question{24.A}

\question{24.B}

\question{24.C}

\question{24.D}



\end{document}