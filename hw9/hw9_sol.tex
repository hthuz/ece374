\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{./img}}
\usepackage{listings}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\algnewcommand{\beginComment}{\textbf{/*}}
\algnewcommand{\endComment}{\textbf{*/}}
\renewcommand{\Comment}[1]{\beginComment~#1~\endComment}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}
% set HW number
\newcommand{\HWnum}{9}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu$^\ast$, 3200110457}
\newcommand{\StudentB}{Suhao Wang, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
	\textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header


\question{25.A}

G is represented with $(V,E)$ with number of vertices $n$ and number of edges $m$. Define $d(v,i,j)$ as the minimum distance from $s$ to $v$ among all walks containing at most $i$ total edges and $j$ checkpoint edges to go. Denote the edges with checkpoints as $E'$ and total number as $m'$. There's

\begin{equation*}
	d(v,i,j) = min
	\begin{cases}
		d(v,i - 1,j)                                      \\
		min_{(u,v) \in E'}
		\begin{cases}
			d(u, i - 1, j - 1) + w(u,v) & \mbox{if $j \ge 1$} \\
			d(u, i - 1, j) + w(u,v)     & \mbox{if $j = 0$}
		\end{cases} \\
		min_{(u,v) \notin E'}\ d(u, i - 1, j) + w(u,v)
	\end{cases}
\end{equation*}


The base cases $d(v,i,0)$ is the minimum distacne from $s$ to $v$ among all walks containing at most $i$ edges without taking checkpoint edges into account and it can be computed using Bellman-Ford algorithm on directed graph $G(V,E)$. The result is $d(t,2n - 1,2)$. Note that two times of travelling through the same road segment are required to make sure 2 checkpoint edges are passed. The algorithm is correcct as its a extension of Bellman-Ford algorithm and takes chekcpoint edges into account. It requires that the path must pass two checkpoint edges.

\begin{algorithm}
	\begin{algorithmic}
		\Function{$GraphCartsFastestPath$}{$G(V,E),s,t$}
		\For{all $v$ in $E$ and $i \in [0..2n - 1]$}
		\State $d(v,i,0) \gets$ minimum distance computed using Bellman-Ford algorithm
		\EndFor

		\For{$i = 0\ to\ 2n - 1$}
		\For{$j = 0\ to\ 2$}
		\For{each edge$(u,v) \in E$}
		\begin{equation*}
			d(v,i,j) = min
			\begin{cases}
				d(v,i - 1,j)                                      \\
				min_{(u,v) \in E'}
				\begin{cases}
					d(u, i - 1, j - 1) + w(u,v) & \mbox{if $j \ge 1$} \\
					d(u, i - 1, j) + w(u,v)     & \mbox{if $j = 0$}
				\end{cases} \\
				min_{(u,v) \notin E'}\ d(u, i - 1, j) + w(u,v)
			\end{cases}
		\end{equation*}
		\EndFor
		\EndFor
		\EndFor

		\Return $d(t,2n - 1, 2)$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Bellman-Ford algoritm takes time O(nm). To compute $(d,i,j)$, there are $2n * 3$ rounds in total and each round takes time $O(m)$. So the time complexity is $O(6nm) = O(nm)$

\question{25.B}

Based on part A, define $d(v,i,j,k)$ as the minimum distance from $s$ to $v$ among all walks containing at most $i$ total edges, $j$ checkpoint edges to go and $k$ "Time Freeze" powerup left. Similarily, we have:

\begin{equation*}
	d(v,i,j,k) = min
	\begin{cases}
		d(v,i - 1,j,k)                                      \\
		\mbox{if $k = 1$}\begin{cases}

		min_{(u,v) \in E'}
		\begin{cases}
			min(d(u, i - 1, j - 1, k) + w(u,v), d(u,i - 1, j - 1, k - 1)) & \mbox{if $j \ge 1$} \\
			min(d(u, i - 1, j, k) + w(u,v),d(u, i - 1, j - 1, k - 1))     & \mbox{if $j = 0$}
		\end{cases} \\
		min_{(u,v) \notin E'}\ min(d(u, i - 1, j, k) + w(u,v),d(u, i - 1, j, k - 1))

		\end{cases} \\

		\mbox{if $k = 0$}\begin{cases}
		min_{(u,v) \in E'}
		\begin{cases}
			d(u, i - 1, j - 1, k) + w(u,v) & \mbox{if $j \ge 1$} \\
			d(u, i - 1, j, k) + w(u,v)     & \mbox{if $j = 0$}
		\end{cases} \\
		min_{(u,v) \notin E'}\ d(u, i - 1, j, k) + w(u,v)
		\end{cases}
	\end{cases}
\end{equation*}

When there's still powerup, take the optimal choice when we use the powerup and when there's no powerup, the situation is the same as above. The base case is $d(v,i,0,0)$, which can still be computed using Bellman-Ford algorithm. The time complexity in this cases is Similarily $O(2n * 3 * 2 * m) = O(12nm) = O(nm)$


\begin{algorithm}
	\begin{algorithmic}
		\Function{$GraphCartsFastestPathWithTimeFreeze$}{$G(V,E),s,t$}
		\For{all $v$ in $E$ and $i \in [0..2n - 1]$}
		\State $d(v,i,0,0) \gets$ minimum distance computed using Bellman-Ford algorithm
		\EndFor

		\For{$i = 0\ to\ 2n - 1$}
		\For{$j = 0\ to\ 2$}
		\For{$k = 0\ to\ 1$}
		\For{each edge$(u,v) \in E$}
\begin{equation*}
	d(v,i,j,k) = min
	\begin{cases}
		d(v,i - 1,j,k)                                      \\
		\mbox{if $k = 1$}\begin{cases}

		min_{(u,v) \in E'}
		\begin{cases}
			min(d(u, i - 1, j - 1, k) + w(u,v), d(u,i - 1, j - 1, k - 1)) & \mbox{if $j \ge 1$} \\
			min(d(u, i - 1, j, k) + w(u,v),d(u, i - 1, j - 1, k - 1))     & \mbox{if $j = 0$}
		\end{cases} \\
		min_{(u,v) \notin E'}\ min(d(u, i - 1, j, k) + w(u,v),d(u, i - 1, j, k - 1))

		\end{cases} \\

		\mbox{if $k = 0$}\begin{cases}
		min_{(u,v) \in E'}
		\begin{cases}
			d(u, i - 1, j - 1, k) + w(u,v) & \mbox{if $j \ge 1$} \\
			d(u, i - 1, j, k) + w(u,v)     & \mbox{if $j = 0$}
		\end{cases} \\
		min_{(u,v) \notin E'}\ d(u, i - 1, j, k) + w(u,v)
		\end{cases}
	\end{cases}
\end{equation*}
		\EndFor
		\EndFor
		\EndFor
		\EndFor

		\Return $d(t,2n - 1, 2,1)$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\question{25.C}

Define $d(v,i,k)$ as the minimum distance from $s$ to $v$ among all walks containing at most $i$ total edges and $k$ "Negative Time" Powerup. In this problem, assume the "Negative Time" powerup is valid only in current traversal. For example, if travelling time from $v1$ to $v2$ is 2 and player uses powerup, he can traverse in time $-3$ but if the player goes back and want to pass $v1,v2$ again, the time is still $2$ if the player doesn't use another powerup. In such a case, the won't be negative cycle once the powerups are all used. There's
\begin{equation*}
	d(v,i,k) = min
	\begin{cases}
		d(v,i - 1,k) \\
		d(v,i,k - 1) - 5 \mbox{ if $k \ge 0$} \\
		min_{(u,v) \in E}\ d(u, i - 1, k) + w(u,v)
	\end{cases}
\end{equation*}

The base case $d(v,i,0)$ can be computed using Bellman-Ford algorithm. The algorithm takes "Negative Time" into account by adding $d(v,i,k - 1) - 5$. Since checkpoint pathes are not required, $n - 1$ times are enough and the output is $d(t,n - 1, k)$. The time complexity is $O(nmk)$

\begin{algorithm}
	\begin{algorithmic}
		\Function{$GraphCartsFastestPath$}{$G(V,E),s,t$}
		\For{all $v$ in $E$ and $i \in [0..n - 1]$}
		\State $d(v,i,0) \gets$ minimum distance computed using Bellman-Ford algorithm
		\EndFor

		\For{$i = 0\ to\ n - 1$}
		\For{$j = 0\ to\ k$}
		\For{each edge$(u,v) \in E$}
\begin{equation*}
	d(v,i,k) = min
	\begin{cases}
		d(v,i - 1,k) \\
		d(v,i,k - 1) - 5 \mbox{ if $k \ge 0$} \\
		min_{(u,v) \in E}\ d(u, i - 1, k) + w(u,v)
	\end{cases}
\end{equation*}
		\EndFor
		\EndFor
		\EndFor

		\Return $d(t,n - 1, k)$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\question{26}\\
$f[i][k]$ denotes collecting gold from subtree of $i$ containing node $i$ while using no more than $k$ rails below node $i$. Every node $i$ has at most three subnode, set them as $j_1$,$j_2$,$j_3$.
\begin{equation*}
	f[i][k] = g(i)+ max
	\begin{cases}
		f[j_1][k-1]                                                   \\
		f[j_2][k-1]                                                   \\
		f[j_3][k-1]                                                   \\
		f[j_1][k-2-m]+f[j_2][m],m \in [0,k-2]                         \\
		f[j_2][k-2-m]+f[j_3][m],m \in [0,k-2]                         \\
		f[j_3][k-2-m]+f[j_1][m],m \in [0,k-2]                         \\
		f[j_1][k-3-m-n]+f[j_2][m]+f[j_3][n],m+n \in [0,k-3],m>=0,n>=0 \\
	\end{cases}
\end{equation*}
For each node, it has several options.
\\1. It can select a node and assign k-1 tracks to it
\\2. It can choose two nodes and assign a total of k-2 tracks to them
\\3. It can select three nodes and assign a total of k-3 tracks to them\\
\textbf{notes:}
\\1. An optimal solution using k rails cannot be derived from an optimal solution using k-1 rails, because it is possible that "$g(i) = 0$" and "$g(subnode(i)) = large number$".
\\2. In this algorithm, some results of dynamic programming are not the actual situation, that is to say, there may be some numbers in $n^2$ A array greater than the final result $A[0][L]$. But they have no way to connect to the root node.
\\3. Initially set $A[u][0] = g(u)$ because it means "this node is selected and there are no other tracks in the subtree of this node".
\\4. $fakenode$ is used because some nodes may have fewer than three self-nodes. Let's say that $g(u)$ of these nonexistent nodes is equal to 0, so that we can write the algorithm. One possible question is the number of tracks used. Suppose a node has only two children, it assumes a $fakenode$, and since this nonexistent node wastes a rail, the final result is bound to be less than the result using two children and the result using one child. So there are no mistakes.\\
\begin{lstlisting}
# N is the number of nodes, L is limited number of belts, g is the function given.
# assume that the larger number of node is in the bottom
dyncraft (g,N,L):  

	# initialize
	int f[0...N-1][0...L]
	int subnode[0...2]  		# at most three subnode
	for i = 0 ...N-1 do  A[i][0] = g(i)
	for i = 0 ...2 	 do  subnode[0...2] = fakenode
	
	# dynamic programming
	for k = 1...L do
	    for i = N-1...0 do
	        count = 0
	        for t in adj(i) do  	# directed tree
	            subnode[count++] = t
	        j_1 = subnode[0]
	        j_2 = subnode[1]
	        j_3 = subnode[2]
	        # cases
	        case = []
	        case.append(f[j_1][k-1])
	        case.append(f[j_2][k-1])
	        case.append(f[j_3][k-1])
	        for m = 0...k-2 do
	            case.append(f[j_1][k-2-m]+f[j_2][m]) 
		   	   case.append(f[j_2][k-2-m]+f[j_3][m])
		         case.append(f[j_3][k-2-m]+f[j_1][m])
	        for m = 0...k-3 do
	            for n = 0...k-3-m do
		            case.append(f[j_1][k-3-m-n]+f[j_2][m]+f[j_3][n])
	        # store the result
	        f[i][k] = g(i) + max(case)
	# final result
	return f[0][L]

\end{lstlisting}
Since $L = O(n)$, the worst case total time is in $O(n^4 + n*m)$, where n is the node number, m is the edge number.\\
the space used is in $O(n^2)$.\\


\question{27.A}

For closed walk $e_1e_2\dots e_l$, denote the edge with maximum weight as $e_m$. Then the max-norm of the closed walk is $w(e_m)/l$. For any closed walk, there is a corresponding simple cycle with subsets of $e_1e_2\dots e_l$ containing $e_m$. But the simple cycle has max-norm greater than or equal that of the closed walk as the number of edges is the simple cycle is smaller than or equal to number of edges in closed walk. Among all closed walks, their corresponding simple cycles have greater max-norm and each simple cycle is a closed walk as well. So there's a simple cycle with max-norm = maximum of any closed walk W in the graph.

\question{27.B}

To find the cycle with largest {\em max-norm}, one simple way is to find all cycles, compute their max-norm and chooses the one with the highest max-norm. To find all cycles, one efficient way is to use Donald B.Johnson's algorithm to find all simple cycles in $O((n + m)(c + 1))$ time, where $c$ is number of simple cycles\cite{doi:10.1137/0204007}. To compute each cycle's max-norm, in worest time, it takes time $O(c(m))$. It takes $O(c)$ time to get the highest max-norm. So the time complexity is $O(n + m)(c + 1)$.

\bibliographystyle{plain}
\bibliography{ref}

\end{document}