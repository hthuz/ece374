\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
%\usepackage{graphicx}
\usepackage{amsmath}

%% Presenet code
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}

% set HW number
\newcommand{\HWnum}{6}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu, 3200110457}
\newcommand{\StudentB}{Suhao Wang$^\ast$, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
  \textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header

% =============

\question{16.A}
last\_choice is used to record the last letter selected to be added to the string.
\\Select the letter from the back to the front, the pricinple is:
\\if A[i] has restrictions on the previous letter, use max to decide whether to add that letter.(E)
\\If A[i] has no restriction on the previous letter, select it if you can. (C,N,none)
\\If A[i] can broaden the selection of the previous letter, select it. (Y,S)
\\Because $$LS (A[1...i], Y \ \vline\ S) > LS (A[1...i], C \ \vline\ N \ \vline\ none) > LS (A[1...i], E)$$
\begin{lstlisting}
def LS(A[1...i], last_choice):
	if i =0 then return 0
	quit = LS(A[1...i-1],last_choice)
	choose = 1 + LS(A[1...i-1],A[i])

	if (last_choice == E): 
		if (A[i] == C): result = choose
		if (A[i] != C): result = quit
	
	if (last_choice == Y or S): 
		if (A[i] == E): result = max{choose, quit}
		if (A[i] == N): result = choose
		if (A[i] == Y or S): result = choose
		if (A[i] == C): result = max{choose, quit} 
		# even though when A[i]==C, choose>=quit, use max to chontain all the longest subsequence. think about the case "...NCY..."
	
	if (last_choice == C or N or NONE):
		if (A[i] == E): result = max{choose,quit}
		if (A[i] == N): result = quit
		if (A[i] == Y or S or C): result = choose
	return result
def LRS(A[1...n]):
	return LS(A[1...n],NONE)
\end{lstlisting}
To make the decision principle stupid, it could become:
\begin{lstlisting}
def LS(A[1...i], last_choice):
	if i =0 then return 0
	quit = LS(A[1...i-1],last_choice)
	choose = 1 + LS(A[1...i-1],A[i])

	if (last_choice == E and A[i]!=C) or (last_choice == C or N or NONE and A[i] == N): 
		result = quit
	else:
		result = max{choose, quit}
	return result
def LRS(A[1...n]):
	return LS(A[1...n],NONE)
\end{lstlisting}
A[1...n], A[1...n-1], A[1...n-2]... There is n.
\\ last\_choice must be (none,E,N,Y,C,S), which is constant.
\\ The resulting algorithm runs in T(n) = O(n)

\question{16.B}
Using a similar idea to the first question.\\
LDS(i,last\_choice) denote the length of the longest subsequence of A[1...i] where the last  element in the longest subsequence meet the requirement of t[j].
\\$muxcase$ =  otherwise
\\$quitcase$ = ($i>=1$ and ((t[j]=E and A[i]!=C) or (t[j]= C,N,NONE and A[i] = N)))
\begin{equation*}
LDS(i,j) = 
  \begin{cases}
    0 & \mbox{if } i < 1 \\
    max\{1+LDS(i-1,hash(A[i])),LDS(i-1,j)\} & \mbox{if }  mux case \\
    LDS(i-1,j) & \mbox{if }    quit case \\
  \end{cases}
\end{equation*}
\begin{lstlisting}
def LDS(A[1...n]):
	A[n+1] = none
	t[j] = {none,E,N,Y,C,S}
	hash({none,E,N,Y,C,S}) = {0,1,2,3,4,5}
	for  j<- 0 to 5
		space_array[n+1,j] = 0
	for i <- n down to 1
		for j = 5 to 0
			if ((t[j]=E and A[i]!=C) or (t[j]= C,N,NONE and A[i] = N)):
				space_array[i,j] = space_array[i-1,j]
			else:
				space_array[i,j] = max{space_array[i-1,j],1+LDS(i-1,hash(A[i])}
	
	return space_array[1,0]	
\end{lstlisting}
The resulting algorithm runs in O(n) time.\\
The space used is in O(n).\\


\question{17.A}

A resursive approach can be applied. To find the highest quality substring {\em hqs(1, n)}, there are two cases, If {\em hqs(i, j)} has a higher quality, update recorded new highest quality. If {\em hqs(i,j)} has a lower quality, recursively find among other substrings.

So define {\em hqs(i,j, h)}, where $(i,j)$ represents $x[i...j]$ and h represents recorded highest quality so far, we have

\begin{equation*}
hqs(i,j,h) = 
  \begin{cases}
    h & \mbox{if } i = j \\
    hqs(i, j, q(i, j)) & \mbox{if } q(i, j) > h \\
    max(hqs(i + 1, j, h), hqs(i, j - 1, h)) & \mbox{if } q(i,j) \le h
  \end{cases}
\end{equation*}

Higest quality substring of x can be found by calling {\em hqs(1, n, 0)}. There are $n \choose 2$ subproblems in total and for each subproblem, we need it requires $O(1)$ time not counting recursive calls. So the time complexity of the algorithm is $O(n^2)$.

\question{17.B}

For substrings $x_1, x_2, x_k$ of a string $x$ of length $n$, it can be represented with a cut arrary of length $n - 1$. In cut array, 1 represents cut the string in this position and 0 otherwise. For example, substrings ("CAT","DOG") can be represented by (00100), cutting at the third interval from left to right. and ("CA", "TO", "OG") can be represented by (01010). It can be found the cutting array can be represented by a binary number $cut\_num$. So the resursive way is to find the maximum quality of decomposition with the observation
$$
decompmax(cut\_num) = max(decomp(cut\_num), decompmax(cut\_num + 1))
$$
with base case $decompmax(2 ^ n) = 0$. The dynamic programming algorithm to solve this problem is as follows:
\begin{lstlisting}
def decompmax_dp():
  M[0... 2 ** n - 1]
  M[2 ** n - 1] = 0
  for cut_num in range(2 ** n - 2, -1, -1):
    M[i] = max(decomp(cut_num),M[cut_num + 1] )
  return M[0]
\end{lstlisting}
Note the here $decomp$ function takes $cut\_num$ as argument and use this value to get the quality of this decomposition. There is $2 ^ n - 1$ subproblems in total and each subproblem requires constant time ignoring resursive calls. The time complexity and space complexity of the algorithm is both $O(2^n)$.

\question{17.C}

Similar to Q17.B, we just need to need to find the best average quality. We can do the modification as follows:
\begin{lstlisting}
def decompavgmax_dp():
  M[0... 2 ** n - 1]
  M[2 ** n - 1] = 0
  for cut_num in range(2 ** n - 2, -1, -1):
    M[i] = max(decomp(cut_num) / (num of 1s in cut_num),M[cut_num + 1] )
  return M[0]
\end{lstlisting}

The number of subproblems doesn't change and each subproblem still requires constant time ignoring resursive calls. The time complexity and space complexity of the algorithm is $O(2^n)$

\question{18.A}

\question{18.B}

\question{18.C}

\end{document}
