\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
%\usepackage{graphicx}
\usepackage{amsmath}

%% Presenet code
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}

% set HW number
\newcommand{\HWnum}{7}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu$^\ast$, 3200110457}
\newcommand{\StudentB}{Suhao Wang, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
  \textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header

% =============

\question{19}

\question{20}
\\This problem can be solved either using dynamic programming, which considers each subtree, or using greedy algorithms, because each time edge is selected there is a best option. We chose to use the greedy algorithm.


\noindent
\\First, define that for node i,
\\$children\_edge$ is the list of edges "$i->children\_node(i)$"
\\$parent\_edge$ is the edge "$parent\_node(i)->i$"


\noindent
\\Then start to consider the leaf nodes of the tree first.
\\Because if you start with the middle node, there's no way to know if you should choose the edge, but if you start with the leaf nodes, since they don't have children nodes, it becomes pretty obvious. There are two choices.
\\1. If they choose children edge, they will only satisfy the number of their own f function requirements.
\\2. If the parent edge is selected, it can be used to meet the requirements of f function of the parent node as well as its own.


\noindent
\\ Therefore, according to the greedy algorithm, for example, if the leaf node needs zero edges "at this time", it will choose nothing. If it needs one or more edge, it will choose the parent edge first, and then any of the other children edges.
\\ after making the set of leaf nodes' need\_num all to zero. We will remove these nodes and get a new group of leaf nodes who don't have children nodes, which is not necessarily the father node of the previous leaf nodes. (consider different height of leaf node) we must consider the children\_node to decide that.
\\ Repeat the steps until all the nodes are removed.


\noindent
\\There are three important points to note: 
\\1. If a node selects its parent edge, it must update some arrays of the parent node. 
\\2. need\_num needs to be updated in real time and may be negative, but it doesn't matter, our function will end up choosing the least edge so that all nodes have need\_num less than 0.
\\3. Our function appears to use multiple loops, "while, for, while", but in fact its process is similar to dynamic programming: it ends up simply iterating through all nodes and exiting the while loop. So the time complexity is still O (n). The space complexity is also O (n), we only use c lists, and the maximum size of a list is n.


\noindent
\\$parent\_node$ is a list used to record parent node , 
\\$children\_node$ is a nested list used to record children node, 
\\$children\_edge$ is a nested list used to record children edge, 
\\$parent\_edge$ is used to record the parent edge, 
\\$need\_num$ is used to record the number of edges it requires. It will change dynamically.


\begin{lstlisting}
def minisize(original_Tree, f):
	X = [ ]		# the result subset
	Tree = original_Tree
	leaf_node_list = [ ]
	new_leaf_list = [ ]

	# initialize the data
	for i in Tree.nodes():
		  	need_num[i] = f(i)
			children_node[i] = # list of all the children nodes of i
			children_edge[i] = # list of all the children edges of i
			parent_node[i]   = # the parent node of i
			parent_edge[i]   = # the parent edge of i
			if (i is leaf_node):
					new_leaf_node_list.append(i)

	while (Tree.nodes() is non-empty):
			leaf_node_list = new_leaf_list
			new_leaf_list = [ ]
			for i in leaf_node_list:  
					while need_num[i]>0:
							if (parent_edge[i] is not none):
									choose_edge = parent_edge[i]
									parent_edge[i] = none
									need_num[parent_node[i]]-=1
									Remove choose_edge from children_edge[parent[i]] 
							else:
									choose_edge = # any edge in children_edge[i]

							    	Remove choose_edge from children_edge[i]
							X.append(choose_edge)
							need_num[i] -= 1
							# justify if need to break when the f(i) is not possible
					Remove i from Tree
					if (parent_node[i] has no children and not in the list):
						new_leaf_list.append(parent_node[i])
			
	lengthX = len(X)
	return X, lengthX

# notes:
# Tree.nodes() will return the list of all the nodes
# We maintain some arrays to save time

\end{lstlisting}
There are n vertices. Set the arrays needs $n$ time, while loop totally run n time. The size of arrays are in O(1) since degrees are at most 3. Running time is T(n) = O(n). Space used is O(n).\\

\question{21.A}

Denote $j$ as $\pi(i)$, $j \in [1,m]$. Let f(i, j) be a boolean function that is True if there's a feasible schedule that ends up main army at $p_i$ and shadow army at $q_j$. For a particular day $i$, the interval if feasible if there exists $j$ such that $\|p_i - q_j\| \in [x,y]$. For $f(i,j)$ to be true, there must exists a schedule to let the interval feasible on day $i - 1$. Formally, there's 

\begin{equation*}
f(i, j) = 
	\begin{cases}
	True & \mbox{if } i = 1, j = 1 \\
	True & \mbox{if } i = 1 \mbox{ and } \|p_i - q_j\| \in [x,y] \\
	True & \mbox{if } i > 1 \mbox{ and }\|p_i - q_j\| \in [x,y] \\
		& \mbox{ and exists k $\in$ $[1,j]$ such that $f(i - 1, k)$ is $True$} \\
	False & \mbox{if } i = 1 \mbox{ and } \|p_i - q_j\| \notin [x,y] \\
	False & \mbox{if }  i > 1 \mbox{ and } \|p_i - q_j\| \in [x,y] \\
		& \mbox{ but there's no k$\in$ $[1,j]$ such that $f(i - 1, k)$ is $True$ } \\
	False & \mbox{if } \|p_i - q_j\| \notin [x,y]
	\end{cases}
\end{equation*}

The output is $f(n, m)$. Based on the recursive equation, a dynamic programming approach with space saving is as follows.

\begin{lstlisting}
	IsFeasible(p[1..n], q[1..m], x,y):
		if ||p[1] - q[1]|| not in [x,y]:
			return False
		bool M[2][1..m] 
		# Initialize
		M[1][1..m] = True

		for i = 2 to n:
			for j = 1 to m:
				if ||p[i] - q[j] not in [x,y]:
					M[2,j] = False
					continue
				# ||p[i] - q[j] is in [x,y]
				if M[1,j] is True:
					M[2,j] = True
				else:
					M[2,j] = False
			# Stores information about existence of feasibility
			M[1,1] = M[2,1]
			for j = 2 to m:
				M[1,j] = M[1,j - 1] OR M[2,j] # Logical operation OR

		return M[n,m]	
\end{lstlisting}

Since only two rows of information are used, we only use M[1][1..m] and M[2][1..m] to store these information. M[1][1..m] stores doesn't store previous result directly since there will be additional $O(m)$ time to check if there exists $k \in [1,j]$ such that $M[1][1..k]$ is true. Instead, it directly shows if such $k$ exists by using logical operation OR. $M[1][1..k]$ being True directly shows that the schedule on former day is feasible. The time complexity is $O(nm)$ and the space complexity is $O(2m)$.

\question{21.B}

For all possible values of $x$, find the one with maximal value. The choice of $x$ can be any value of $\|p_i - q_j\|$. Not all possible values of $x$ are feasible and among these feasible ones, find the maximal one. The algorithm is as follows.
\begin{lstlisting}
	# L[a..b] is sorted in increasing order
	search_maximal(L[a..b]):
		if ( b - a <= 0) return L[a]
		mid = D[floor((a + b) / 2)]
		if IsFeasible(p[1..n],q[1..m], mid, inf):
			return search_maximal(L[mid..b])
		else:
			return search_maximal(L[a..mid - 1])
\end{lstlisting}

The input to $search\_maximal(L[a..b])$ is sorted version of all values of $\|p_i - q_j\|$, where $i \in [1..n]$ and $j \in [1..m]$ with lenght $mn$. The basic idea is to use binary seach to find the maximal feasible value of x. To sort $L[1..nm]$, the time required is $O(nmlog(nm))$. The searching process takes $O(log(nm))$ time according to binary seach and for each search, $IsFeasible$ takes $O(nm)$ time. So the total time required is $O(nmlog(nm))$.

\question{21.C}

To find the interval with minimum instability $y / x$, the equivalent solution is to find the maximal possible value of $x$ and the minimal possible value of $y$. To find the minimal feasible value of $y$, a similar approach as in Q21.B can be applied. The algorithm is as follows.

\begin{lstlisting}
	search_min_instability(Sorted(L[0..nm])):
		x = serach_maximal(L[0..nm])
		y = search_minimal(L[0..nm])
		return (x,y)
	
	# L[a..b] is sorted in increasing order
	search_minimal(L[a..b]):
		if ( b - a <= 0) return L[a]
		mid = D[floor((a + b) / 2)]
		if IsFeasible(p[1..n],q[1..m], 0, mid):
			return search_maximal(L[a..mid])
		else:
			return search_maximal(L[mid + 1..b])
\end{lstlisting}

The input to $serach_min_instability$ is still sorted version of all values of $\|p_i - q_j\|$, where $i \in [1..n]$ and $j \in [1..m]$ with lenght $mn$. The time complexity is still the same as before: $O(nmlog(nm))$

\end{document}