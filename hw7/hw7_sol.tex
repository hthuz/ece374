\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
%\usepackage{graphicx}
\usepackage{amsmath}

%% Presenet code
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}

% set HW number
\newcommand{\HWnum}{7}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu, 3200110457}
\newcommand{\StudentB}{Suhao Wang$^\ast$, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
  \textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header

% =============

\question{19}

\question{20}
\\We can try to satisfy the number of f (nodes) by starting with the leaves of the tree.For each node:
\\$parent\_node$ is used to record its parent node, 
\\$children\_edge$ is used to record the edge below the node, 
\\$parent\_edge$ is used to record the edge above it, 
\\$need\_num$ is used to record the number of edges it requires. It will change dynamically.\\


\noindent
For each leaf node, when the number of edges it requires is greater than 0:
\\1. If there is a parent edge, select it and update the arrays.
\\2. If you don't have a parent edge, pick a child edge. Update corresponding arrays.
\\Repeat the preceding steps to update the array of leaf nodes.

\begin{lstlisting}
def minisize(original_Tree, f):
	X = [ ]
	Tree = original_Tree
	leaf_node_list = [ ]
	new_leaf_list = [ ]
	for i in Tree.nodes():
		  	need_num[i] = f(i)
			children_node[i] = # list of all the children nodes of i
			children_edge[i] = # list of all the children edges of i
			parent_node[i]   = # the parent node of i

			if (i is leaf_node):
					leaf_node_list.append(i)

	while (Tree.nodes() is non-empty):
			leaf_node_list = new_leaf_list
			new_leaf_list = [ ]
			for i in leaf_node_list:  
					while need_num[i]>0:
							if (parent_edge[i] is not none):
									dedge = parent_edge[i]
									parent_edge[i] = none
									need_num[parent_node[i]]-=1
									Remove dedge from children_edge[parent[i]] 
							else:
									dedge = # any edge in children_edge[i]
							    	Remove dedge from children_edge[i]
							X.append(dedge)
							need_num[i] -= 1
					Remove i from Tree
					if (parent[i] is not in new_leaf_list):
						new_leaf_list.append(parent[i])
			
	lengthX = len(X)
	return X, lengthX

# notes:
# Tree.nodes() will return the list of all the nodes
# We maintain some arrays to save time

\end{lstlisting}
There are n vertices. Set the arrays needs $n$ time, while loop totally run n time. The size of arrays are in O(1) since degrees are at most 3. Running time is T(n) = O(n). Space used is O(n).

\question{21.A}

Denote $j$ as $\pi(i)$, $j \in [1,m]$. Let f(i, j) be a boolean function that is True if there's a feasible schedule that ends up main army at $p_i$ and shadow army at $q_j$. For a particular day $i$, the interval if feasible if there exists $j$ such that $\|p_i - q_j\| \in [x,y]$. For $f(i,j)$ to be true, there must exists a schedule to let the interval feasible on day $i - 1$. Formally, there's 

\begin{equation*}
f(i, j) = 
	\begin{cases}
	True & \mbox{if } i = 1, j = 1 \\
	True & \mbox{if } i = 1 \mbox{ and } \|p_i - q_j\| \in [x,y] \\
	True & \mbox{if } i > 1 \mbox{ and }\|p_i - q_j\| \in [x,y] \\
		& \mbox{ and exists k $\in$ $[1,j]$ such that $f(i - 1, k)$ is $True$} \\
	False & \mbox{if } i = 1 \mbox{ and } \|p_i - q_j\| \notin [x,y] \\
	False & \mbox{if }  i > 1 \mbox{ and } \|p_i - q_j\| \in [x,y] \\
		& \mbox{ but there's no k$\in$ $[1,j]$ such that $f(i - 1, k)$ is $True$ } \\
	False & \mbox{if } \|p_i - q_j\| \notin [x,y]
	\end{cases}
\end{equation*}

The output is $f(n, m)$. Based on the recursive equation, a dynamic programming approach with space saving is as follows.

\begin{lstlisting}
	IsFeasible(p[1..n], q[1..m], x,y):
		if ||p[1] - q[1]|| not in [x,y]:
			return False
		bool M[2][1..m] 
		# Initialize
		M[1][1..m] = True

		for i = 2 to n:
			for j = 1 to m:
				if ||p[i] - q[j] not in [x,y]:
					M[2,j] = False
					continue
				# ||p[i] - q[j] is in [x,y]
				if M[1,j] is True:
					M[2,j] = True
				else:
					M[2,j] = False
			# Stores information about existence of feasibility
			M[1,1] = M[2,1]
			for j = 2 to m:
				M[1,j] = M[1,j - 1] OR M[2,j] # Logical operation OR

		return M[n,m]	
\end{lstlisting}

Since only two rows of information are used, we only use M[1][1..m] and M[2][1..m] to store these information. M[1][1..m] stores doesn't store previous result directly since there will be additional $O(m)$ time to check if there exists $k \in [1,j]$ such that $M[1][1..k]$ is true. Instead, it directly shows if such $k$ exists by using logical operation OR. $M[1][1..k]$ being True directly shows that the schedule on former day is feasible. The time complexity is $O(nm)$ and the space complexity is $O(2m)$.

\question{21.B}

For all possible values of $x$, find the one with maximal value. The choice of $x$ can be any value of $\|p_i - q_j\|$. Not all possible values of $x$ are feasible and among these feasible ones, find the maximal one. The algorithm is as follows.
\begin{lstlisting}
	# L[a..b] is sorted in increasing order
	search_maximal(L[a..b]):
		if ( b - a <= 0) return L[a]
		mid = D[floor((a + b) / 2)]
		if IsFeasible(p[1..n],q[1..m], mid, inf):
			return search_maximal(L[mid..b])
		else:
			return search_maximal(L[a..mid - 1])
\end{lstlisting}

The input to $search\_maximal(L[a..b])$ is sorted version of all values of $\|p_i - q_j\|$, where $i \in [1..n]$ and $j \in [1..m]$ with lenght $mn$. The basic idea is to use binary seach to find the maximal feasible value of x. To sort $L[1..nm]$, the time required is $O(nmlog(nm))$. The searching process takes $O(log(nm))$ time according to binary seach and for each search, $IsFeasible$ takes $O(nm)$ time. So the total time required is $O(nmlog(nm))$.

\question{21.C}

To find the interval with minimum instability $y / x$, the equivalent solution is to find the maximal possible value of $x$ and the minimal possible value of $y$. To find the minimal feasible value of $y$, a similar approach as in Q21.B can be applied. The algorithm is as follows.

\begin{lstlisting}
	search_min_instability(Sorted(L[0..nm])):
		x = serach_maximal(L[0..nm])
		y = search_minimal(L[0..nm])
		return (x,y)
	
	# L[a..b] is sorted in increasing order
	search_minimal(L[a..b]):
		if ( b - a <= 0) return L[a]
		mid = D[floor((a + b) / 2)]
		if IsFeasible(p[1..n],q[1..m], 0, mid):
			return search_maximal(L[a..mid])
		else:
			return search_maximal(L[mid + 1..b])
\end{lstlisting}

The input to $serach_min_instability$ is still sorted version of all values of $\|p_i - q_j\|$, where $i \in [1..n]$ and $j \in [1..m]$ with lenght $mn$. The time complexity is still the same as before: $O(nmlog(nm))$

\end{document}