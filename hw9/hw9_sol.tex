\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{./img}}
\usepackage{listings}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\algnewcommand{\beginComment}{\textbf{/*}}
\algnewcommand{\endComment}{\textbf{*/}}
\renewcommand{\Comment}[1]{\beginComment~#1~\endComment}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}
% set HW number
\newcommand{\HWnum}{9}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu$^\ast$, 3200110457}
\newcommand{\StudentB}{Suhao Wang, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
  \textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header


\question{25.A}

G is represented with $(V,E)$ with number of vertices $n$ and number of edges $m$. Define $d(v,i,j)$ as the minimum distance from $s$ to $v$ among all walks containing at most $i$ total edges and at least $j$ checkpoint edges. Denote the edges with checkpoints as $E'$ and total number as $m'$. For $j > 0$, there's 

\begin{equation*}
	d(v,i,j) = min
	\begin{cases}
		d(v,i - 1,j) \\
		d(v,i, j + 1) \\
		min_{(u,v) \in E'}\ d(u, i - 1, j - 1) + w(u,v) \\
		min_{(u,v) \notin E'}\ d(u, i - 1, j) + w(u,v) 
	\end{cases}
\end{equation*}

The base cases $d(v,i,0)$ is the minimum distacne from $s$ to $v$ among all walks containing at most $i$ edges and it can be computed using Bellman-Ford algorithm on directed graph $G(V,E)$. The result is $d(v,n - 1, 2)$

\begin{algorithm}
\begin{algorithmic}
	\Function{$GraphCartsFastestPath$}{$G(V,E)$}
	\For{all $v$ in $E$ and $i \in [0..n - 1]$}
	\State $d(v,i,0) \gets$ minimum distance computed using Bellman-Ford algorithm
	\EndFor

	\For{i = 1 to n - 1}
		\For{j = 0 to m'}
			\For{each edge$(u,v) \in E$}
				\begin{equation*}
					d(v,i,j) = min
					\begin{cases}
						d(v,i - 1,j) \\
						d(v,i, j + 1) \\
						min_{\phi(u,v) = 1}\ d(u, i - 1, j - 1) + w(u,v) \\
						min_{\phi(u,v) = 0}\ d(u, i - 1, j) + w(u,v) 
					\end{cases}
				\end{equation*}
			\EndFor
		\EndFor
	\EndFor
	\Return $d(v,n - 1, 2)$
	\EndFunction
\end{algorithmic}
\end{algorithm}

Bellman-Ford algoritm takes time O(nm). To compute $(d,i,j)$ for one round, it takes time $O(m)$ and there are $O(nm')$ such cases. So the time complexity is $O(nmm')$, where $m'$ is the number of checkpont edges.

\question{25.B}

\question{25.C}

\question{26}\\
$f[i][k]$ denotes collecting gold from subtree of $i$ containing node $i$ while using no more than $k$ rails below node $i$. Every node $i$ has at most three subnode, set them as $j_1$,$j_2$,$j_3$.
\begin{equation*}
f[i][k] = g(i)+ max
	\begin{cases}
		f[j_1][k-1]\\
		f[j_2][k-1]\\
		f[j_3][k-1]\\
		f[j_1][k-2-m]+f[j_2][m],m \in [0,k-2]\\
		f[j_2][k-2-m]+f[j_3][m],m \in [0,k-2]\\
		f[j_3][k-2-m]+f[j_1][m],m \in [0,k-2]\\
		f[j_1][k-3-m-n]+f[j_2][m]+f[j_3][n],m+n \in [0,k-3],m>=0,n>=0\\
	\end{cases}
\end{equation*}
For each node, it has several options.
\\1. It can select a node and assign k-1 tracks to it
\\2. He can choose two nodes and assign a total of k-2 tracks to them
\\3. It can select three nodes and assign a total of k-3 tracks to them\\
\textbf{notes:}
\\1. An optimal solution using k rails cannot be derived from an optimal solution using k-1 rails, because it is possible that "$g(i) = 0$" and "$g(subnode(i)) = large$".
\\2. In this algorithm, some results of dynamic programming are not the actual situation, that is to say, there may be some numbers in $n^2$ A array greater than the final result $A[0][L]$. But they have no way to connect to the root node.
\\3. Initially set $A[u][0] = g(u)$ because it means "this node is selected and there are no other tracks in the subtree of this node".
\\4. $fakenode$ is used because some nodes may have fewer than three self-nodes. Let's say that $g(u)$ of these nonexistent nodes is equal to 0, so that we can write the algorithm. One possible question is the number of tracks used. Suppose a node has only two children, it assumes a $fakenode$, and since this nonexistent node wastes a rail, the final result is bound to be less than the result using two children and the result using one child. So there are no mistakes.\\
\begin{lstlisting}
# N is the number of nodes, L is limited number of belts
# assume that the larger number of node is in the bottom
dyncraft (g,N,L):  

	# initialize
	int A[0...N-1][0...L]
	int subnode[0...2]  		# at most three subnode
	int fakenode[0...L] 			# if subnode<3, use it
	for i = 0 ...N-1 do  A[i][0] = g(i)
	for i = 0 ...L 	 do  fake_node[i] = 0
	for i = 0 ...2 	 do  subnode[0...2] = N
	
	# dynamic programming
	for k = 1...L do
	    for i = N-1...0 do
	        count = 0
	        for t in adj(i) do  	# directed tree
	            subnode[count++] = t
	        j_1 = subnode[0]
	        j_2 = subnode[1]
	        j_3 = subnode[2]
	        # cases
	        case = []
	        case.append(f[j_1][k-1])
	        case.append(f[j_2][k-1])
	        case.append(f[j_3][k-1])
	        for m = 0...k-2 do
	            case.append(f[j_1][k-2-m]+f[j_2][m]) 
		   	   case.append(f[j_2][k-2-m]+f[j_3][m])
		         case.append(f[j_3][k-2-m]+f[j_1][m])
	        for m = 0...k-2 do
	            for n = 0...k-2-m dp
		            case.append(f[j_1][k-3-m-n]+f[j_2][m]+f[j_3][n])
	        # store the result
	        A[i][k] = g(i) + max(case)
	# final result
	return A[0][L]

\end{lstlisting}
Since $L = O(n)$, the worst case total time is in $O(n^4 + n*m)$, where n is the node number, m is the edge number.\\
the space used is in $O(n^2)$.\\


\question{27.A}

For closed walk $e_1e_2\dots e_l$, denote the edge with maximum weight as $e_m$. Then the max-norm of the closed walk is $w(e_m)/l$. For any closed walk, there is a corresponding simple cycle with subsets of $e_1e_2\dots e_l$ containing $e_m$. But the simple cycle has max-norm greater than or equal that of the closed walk as the number of edges is the simple cycle is smaller than or equal to number of edges in closed walk. Among all closed walks, their corresponding simple cycles have greater max-norm and each simple cycle is a closed walk as well. So there's a simple cycle with max-norm = maximum of any closed walk W in the graph.

\question{27.B}

To find the cycle with largest {\em max-norm}, one simple way is to find all cycles, compute their max-norm and chooses the one with the highest max-norm. To find all cycles, one efficient way is to use Donald B.Johnson's algorithm to find all simple cycles in $O((n + m)(c + 1))$ time, where $c$ is number of simple cycles\cite{doi:10.1137/0204007}. To compute each cycle's max-norm, in worest time, it takes time $O(c(m))$. It takes $O(c)$ time to get the highest max-norm. So the time complexity is $O(n + m)(c + 1)$.

\bibliographystyle{plain}
\bibliography{ref}

\end{document}