\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
%\usepackage{graphicx}
\usepackage{amsmath}

%% Presenet code
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\algnewcommand{\beginComment}{\textbf{/*}}
\algnewcommand{\endComment}{\textbf{*/}}
\renewcommand{\Comment}[1]{\hfill\beginComment~#1~\endComment}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}

% set HW number
\newcommand{\HWnum}{8}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu$^\ast$, 3200110457}
\newcommand{\StudentB}{Suhao Wang, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
  \textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header


% =============

\question{22.A}

Represent the underground tunnel system as a connected undirected graph $G = (V,E)$, where $V$ is the set of intersections of tunnels and $E$ is the set of tunnels. $n$ is size of $V$ and $m$ is size of $E$. To check if a tunnel $e$ is critical, simply check if $G' = (V,E - {e})$ is connected. Use depth first search to determine if $G'$ is connected takes linear time $O(n + m - 1)$.

\begin{algorithm}
\caption{Determine if a edge $e$ is critical}\label{alg:q22A}
\begin{algorithmic}
  \Function{$IsCritical$}{$G(V,E),e$}
    \State $T \gets$ Tree/Forest generated by $DFS((V, E - {e}))$
    \If{$T$ is a Forest(has multiple root nodes)}
      \State \Return True
    \EndIf
    \State \Return False 
  \EndFunction
\end{algorithmic}
\end{algorithm}

\question{22.B}

If tunnel $\{v_i, v_j\}$ is destroyed and cops can't still find a way going from $v_i$ to $v_j$ or from $v_j$ to $V_i$, this shows that there is only one path from $v_i$ to $v_j$ or from $v_j$ to $v_i$, without forming cycles. On other words, $\{v_i, v_j\}$ is critical if it is not an edge of any cycle. To indentify every critical tunnel, do depth first search to find all vertices that are part of a cycle. Then get critical edge from vertices that are not part of any cycle.

\begin{algorithm}
\caption{Find all critical tunnels of $G(V,E)$}\label{alg:q22B}
\begin{algorithmic}
  \Function{$FindCriticalTunnel$}{$G(V,E)$}
    \State $T(V,E') \gets$ Tree generated by $DFS(G)$
    \State $CycleVertices \gets empty$
    \State $CriticalEdge \gets empty$
    \For{ all edges $\{v_i,v_j\}$ in $E - E'$}
      \State $CycleVertices+=v_i,v_j$
    \EndFor
    \For{ all vertices $v_i$ in $V - CycleVertices$}
      \State $CriticalEdge +=$ edges in $Adj(v_i)$
    \EndFor
    \State \Return $CriticalEdge$
  \EndFunction
\end{algorithmic}
\end{algorithm}

DFS takes linear time and finding vertices in cycles as well as find critical edges takes linear time. So the total time complexity is $O(n + m)$.

\question{22.C}

The problem is equivalent to find all critical vertices $v$ such that $G' = (V - \{v\}, E - \mbox{\{edges in Adj(v)\}})$ are disconnected. Suppose vertex $v_i$ is removed and $v_i$ is in one cycle $v_1,v_2...v_i,v_{i+1}...v_1$. Then the rest of vertices are still connected using the edge in reverse order. So critical vertices are those that are in one path without forming a cycle. Use similar approach all critical vertices can be found.

\begin{algorithm}
\caption{Find all critical vertices in graph $G(V,E)$}\label{alg:q22C}
\begin{algorithmic}
  \Function{$FindCriticalIntersetion$}{$G(V,E)$}
    \State $T(V,E') \gets$ Tree generated by DFS(G)
    \State $CycleVertices \gets empty$
    \State $CriticalVertices \gets empty$
    \For{all edges $\{v_i,v_j\}$ in $E-E'$}
      \State $CycleVertices += v_i,v_j$
    \EndFor
    \For{all vertices $v_i$ in $V - CycleVertices$}
      \For{all edges $\{v_i,v_j\}$ in $Adj(v_i)$}
        \State $CriticalVertices \gets CriticalVertices \cup \{v_i,v_j\}$
      \EndFor
    \EndFor
    \State \Return $CriticalVertices$
  \EndFunction
\end{algorithmic}
\end{algorithm}

Note that even though some vertices participate in forming into one cycle, if it also participates in forming a non-cycle path, it is critical as well. Similarily, the time complexity is $O(n + m)$


\question{23.A}\\
1. Topological sorting
\\2. traverse vertex for topological sorting result:
\\If for any vertex $n$ except the last vertex in the list, there is an edge from $n$ to $n+1$, then G has a Hamiltonian path.
\\Otherwise, G doesn't have a Hamiltonian path.
\\3. Explanation: in Hamiltonian path you have to visit all the vertices. In the topological sorting result, you cannot "go back". So the only strategy is to "traverse in turn without skip". 
\begin{lstlisting}
TopSort(G):
	Sorted <- NULL
	deg_in[1....n] <- -1
	Tdeg_in[1...n] <- NULL
	for each edge xy in G do
		deg_in[y] ++
	for each vertex v in G do
		Tdeg_in[deg_in[v]].append(v)
	while (Tdeg_in[0] is non-empty) do
		Remove node x from Tdeg_in[0]
		Sorted.append(x)
		for each edge xy in Adj(x) do
			deg_in[y]--
			move y to Tdeg_in[deg_in[y]]
	Output Sorted
Hami(G):
	Sort_List = TopSort(G)
	for each vertex v in Sorted_List do  # except the last vertex
		have_edge = 0
		for each edge vu in Adj(v) do
			 if (u == vertex v successor): 
				have_edge = 1	
		if (have_edge == 0) do
			return False
	return True

\end{lstlisting}
topsort running time is O(V+E). Hami main function also just go through all the vertices and edges once. Running time is O(V+E).V is the vertex number, E is the edge number.\\

\question{23.B}\\
1. use topological sorting and traverse the vertices of the topological sorting result to realize dynamically programming.
\\2. For each vertex $x$, determine whether $avg\_weight[x]$ is equal to -1. 
\\If it is -1, then $s$ cannot reach the vertex. continue.
\\If it is not equal to -1, it means that $s$ can reach this vertex. Walk through each of its edges, and then update the maximum average weight of all the vertices connected by $x$.
\\3. $avg\_weight[t]$ will store the maximum weight from $s$ to $t$, if it is -1, then $t$ is not reachable for $s$.
\\($avg\_weight[t]$ is the maximum average weight from $s$ to $i$)
\begin{lstlisting}
TopSort(G):
	decribe in A
Avg(G, s, t):
	avg_weight[1.....n] <- -1
	edge_num[1.....n] <- 0
	Sort_List = TopSort(G)
	for each vertex x in Sort_List do
		if (x == s):
			avg_weight[x] = 0
			edge_num[x] = 0
		if (average_weight[x] != -1 ) do
			for each edge xy in Adj(x) do
				new_path = (avg_weight[x]*edge_num[x]+w(xy) )/(edge_num[x]+1)
				# w (xy) is the edge xy's weight
				avg_weight[y] = max{ avg_weight[y], new_path}
				if (new_path == avg_weight[y]) do
					edge_num[y]++
	Output avg_weight[t]
\end{lstlisting}
topsort running time is O(V+E). Avg main function also just go through all the vertices and edges once. Running time is O(V+E).V is the vertex number, E is the edge number.\\


\question{23.C}\\
1. use topological sorting and traverse the vertices of the topological sorting result to realize dynamically programming.
\\2. For each vertex $x$, determine whether $path\_weight[x]$ is equal to -1. 
\\If it is -1, then $s$ cannot reach the vertex. continue.
\\If it is not equal to -1, it means that $s$ can reach this vertex. Walk through each of its edges, and then update the maximum weight of all the vertices connected by $x$.
\\3. $path\_weight[t]$ will store the maximum weight from $s$ to $t$, if it is -1, then $t$ is not reachable for $s$.
\\($path\_weight[i]$ is the maximum weight from $s$ to $i$)
\begin{lstlisting}
TopSort(G):
	decribe in A
Spec(G, s, t):
	path_weight[1.....n] <- -1
	Sort_List = TopSort(G)
	for each vertex x in Sort_List do
		if (x == s):
			path_weight[x] = 0
		if ( path_weight[x] != -1 ) do
			for each edge xy in Adj(x) do
				path_weight[y] = max{ path_weight[y], path_weight[x]+w(y)}
				# w(y) means the weight of vertex y no matter it is special or not
	Output path_weight[t]
\end{lstlisting}
topsort running time is O(V+E). Spec main function also just go through all the vertices and edges once. Running time is O(V+E).V is the vertex number, E is the edge number.\\


\question{23.D}\\
1. First, the DAG is topologically sorted
\\2. The results sorted by topology will be dynamically programmed from front to back
\\(path[i] represents whether the number of different paths from s to vertex i is odd or even. 0 means even, 1 means odd.)
\\3. Start by setting all arrays for dynamic programming to -1,
\\4. Starting at the starting vertex s, set its $path$ to even (because there are zero paths).
\\5. Then all the edges of s are considered, and the vertices connected by s are updated according to $path[s]$. Use "path[y] = (path[y] + path[x]) mod 2" to get the "temporary" parity of the connected vertices.
\\6. Select the next node for topological sort and do the same thing, repeating the previous step until we reach node t.
\\(When we traverse to vertex j, it means that the number of paths for this node has been determined, that is, its parity has been determined)
\begin{lstlisting}
EVEN = 0 
ODD = 1
# (EVEN+ODD) mod 2=ODD, (EVEN+EVEN) mod 2=EVEN, ODD+ODD mod 2= EVEN, 
TopSort(G):
	# decribe in A
even_odd(G, s, t):
	path[1.....n] <- -1
	Sort_List = TopSort(G)
	for each vertex x in Sort_List do
		if (x == s):
			path[x] = EVEN
		if ( path[x] != -1 ) do
			for each edge xy in Adj(x) do
				if ( path[y] == -1 ) do
					path[y] = EVEN
				path[y]  = (path[y] + path[x]) mod 2
	Output path[t]
\end{lstlisting}
topsort running time is O(V+E). even\_odd main function also just go through all the vertices and edges once. Running time is O(V+E).V is the vertex number, E is the edge number.\\
\question{24.A}

{\bf Modeling of problem:} The modeling of the problem can be considered as a directed graph $G(V,E)$ with size of V=$n$ and size of $E$=$m$ and each vertices has one outgoing edge. The edge of a vertex $v$ is represented as $(v \rightarrow contact(v))$. The meta-graph $G^{SCC}$ of $G$ is a DAG, with some sources and sinks. We claim that {\em if a strongly connected component of G has more than one vertices, then this SCC must be a sink in $G^{SCC}$}. In other words, {\em All SCC vertices in $G^{SCC}$ only has one vertex in $G$ except sinks}. This can be proved by contradiction. Suppose there exists a vertex is in a strongly connected component that is not a sink in $G^{SCC}$, then for all vertices in SCC, there must be a outgoing edge from these vertices pointing to another in the SCC. At the same time, for some vertex $v$ in SCC, there will be one outgoing edge from $v$ pointing to some other vertices not in this SCC since it's not in the sink. But the contradicts the condition that each vertex only has one outgoing edge. So there's no such vertex and the claim is true.

Similarily, it can be proved that each source only corresponds to one sink and each sink can correspond to multiple sources.

For problem A, to find a rebel that can propagate to all other vertices, this rebel must be a source in $G^{SCC}$. If there are multiple sources $s_i,s_j$ in $G^{SCC}$. there's no way that $s_i$ can propagate to $s_j$ and vice versa. So to solve the problem, just check the sources of $G^{SCC}$.  


\begin{algorithm}
\caption{Find a rebel that propagates to all}\label{alg:q24A}
\begin{algorithmic}
  \Function{$RebelPropagateAll$}{$G(V,E)$}
    \State $G^{SCC}$ = meta-graph of $G$ obtained in linear time
    \State Compute $InDeg(v)$, in-degree of each vertex in $G^{SCC}$
    \If{Number of vertices with $InDeg(v) = 0$ is greater than 1}
      \State \Return False
    \Else
      \State \Return vertex $v$ with $InDeg(v)$ = 0
    \EndIf
  \EndFunction
\end{algorithmic}
\end{algorithm}

As a rebel can only send messages to one other rebel, the number edge is equal to number of vertex. The linear time algorithm to obtain $G^{SCC}$ in lecture slides can be applied. It takes linear time to compute in-degree of each vertex by traversing through edges and vertices. So the time complexity of the algorithm is $O(n + m) = O(n + n) = O(n)$.

\question{24.B}

If all sources in $G^{SCC}$ is directly sent a message, than all other rebels can receive message. If some rebels that are not sources are directly sent a message, the corresponding source of the rebel still need to be directly sent a message. So minimal number is number of sources in $G^{SCC}$. The algrithom of this problem is almost the same of the problem above, the only difference is that number of sources in $G^{SCC}$ is returned. Time complexity is $O(n)$

\question{24.C}

A rebel can send messages to many other rebels. The claims in {\bf Modeling of Problem} don't hold any more. But similarily, such a rebel exists if there's a source in $G^{SCC}$ that can reach all sinks in $G^{SCC}$. Note that there can be only one source, otherwise rebels in one source can't propagate to rebels in another source. All rebels in the source SCC can propagate message to everyone. The problem is equivalent to check if the number of sources in $G^{SCC}$ is one since if there's some sink that can't be reached by the source, there must exist another source that can reach this sink, which will lead to multiple sources.

\begin{algorithm}
\caption{Find rebels that propagates to all}\label{alg:q24A}
\begin{algorithmic}
  \Function{$RebelPropagateAll$}{$G(V,E)$}
    \State $G^{SCC}$ = meta-graph of $G$ obtained in linear time
    \State Compute $InDeg(v)$, in-degree of each vertex in $G^{SCC}$
    \If{Number of vertices with $InDeg(v) = 0$ is greater than 1}
      \State \Return False
    \Else
      \State \Return vertices in SCC $v$ in $G^{SCC}$ with $InDeg(v)$ = 0
    \EndIf
  \EndFunction
\end{algorithmic}
\end{algorithm}

Similarily, the time complexity is $O(n + m)$

\question{24.D}

For this problem, when we make the meta graph of the original graph to a circle, the number of reassignments can be minimized, which is the number of sinks plus the sum of the corresponding source -1 of the meta graph.

\begin{lstlisting}
  def RebelPropagateAll(G(V,E)):
  list $S_{SCC}$
  num_of_reassignments <- 0
  num_of_sink <- 0
  num_of_cor_source <- 0
  do DFS($G^{rev}$) and output vertices in decreasing post order
  Mark all nodes as unvisited
  for each v in the computed order do
      if v is not visited then 
           DFS(v)
           Let $S_v$ be the nodes reached by v
           Add $S_v$ to $S_{SCC}$
           Remove $S_v$ from G
  for each $S_v$ in $S_{SCC}$ do
      if Adj{$S_v$} = 0
      num_of_sink += 1
      for each $S_v$ in $S_{SCC}^{rev}$ do
               if Adj{$S_v$} = 0
               num_of_cor_source += 1
  num_of_reassignments = num_of_sink + num_of_cor_source - 1
  Output num_of_reassignments        
\end{lstlisting}

The time complexity of this algrithom is $O(n)$.

Proof of correctness of this algrithom:
First, we need to delete one edge of the sink strongly connected component, because a rebel can only send a sigle message to one other rebel, there is at least one edge of each vertex. The number of reassignments of this operation is the number of sinks.
Then, we need to connect the sink to another source to make the whole graph a circle, which need the number of corresponding sources - 1 reassignments. So, the minimal number of contacts of a single rebel is the number of the sink plus the number of the corresponding sources - 1.

\end{document}