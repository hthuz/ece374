\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
%\usepackage{graphicx}
\usepackage{amsmath}

%% Presenet code
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}

% set HW number
\newcommand{\HWnum}{6}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu, 3200110457}
\newcommand{\StudentB}{Suhao Wang$^\ast$, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
  \textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header

% =============

\question{16.A}

\question{16.B}

\question{17.A}

A resursive approach can be applied. To find the highest quality substring {\em hqs(1, n)}, there are two cases, If {\em hqs(i, j)} has a higher quality, update recorded new highest quality. If {\em hqs(i,j)} has a lower quality, recursively find among other substrings.

So define {\em hqs(i,j, h)}, where $(i,j)$ represents $x[i...j]$ and h represents recorded highest quality so far, we have

\begin{equation*}
hqs(i,j,h) = 
  \begin{cases}
    h & \mbox{if } i = j \\
    hqs(i, j, q(i, j)) & \mbox{if } q(i, j) > h \\
    max(hqs(i + 1, j, h), hqs(i, j - 1, h)) & \mbox{if } q(i,j) \le h
  \end{cases}
\end{equation*}

Higest quality substring of x can be found by calling {\em hqs(1, n, 0)}. There are $n \choose 2$ subproblems in total and for each subproblem, we need it requires $O(1)$ time not counting recursive calls. So the time complexity of the algorithm is $O(n^2)$.

\question{17.B}

For substrings $x_1, x_2, x_k$ of a string $x$ of length $n$, it can be represented with a cut arrary of length $n - 1$. In cut array, 1 represents cut the string in this position and 0 otherwise. For example, substrings ("CAT","DOG") can be represented by (00100), cutting at the third interval from left to right. and ("CA", "TO", "OG") can be represented by (01010). It can be found the cutting array can be represented by a binary number $cut\_num$. So the resursive way is to find the maximum quality of decomposition with the observation
$$
decompmax(cut\_num) = max(decomp(cut\_num), decompmax(cut\_num + 1))
$$
with base case $decompmax(2 ^ n) = 0$. The dynamic programming algorithm to solve this problem is as follows:
\begin{lstlisting}
def decompmax_dp():
  M[0... 2 ** n - 1]
  M[2 ** n - 1] = 0
  for cut_num in range(2 ** n - 2, -1, -1):
    M[i] = max(decomp(cut_num),M[cut_num + 1] )
  return M[0]
\end{lstlisting}
Note the here $decomp$ function takes $cut\_num$ as argument and use this value to get the quality of this decomposition. There is $2 ^ n - 1$ subproblems in total and each subproblem requires constant time ignoring resursive calls. The time complexity and space complexity of the algorithm is both $O(2^n)$.

\question{17.C}

Similar to Q17.B, we just need to need to find the best average quality. We can do the modification as follows:
\begin{lstlisting}
def decompavgmax_dp():
  M[0... 2 ** n - 1]
  M[2 ** n - 1] = 0
  for cut_num in range(2 ** n - 2, -1, -1):
    M[i] = max(decomp(cut_num) / (num of 1s in cut_num),M[cut_num + 1] )
  return M[0]
\end{lstlisting}

The number of subproblems doesn't change and each subproblem still requires constant time ignoring resursive calls. The time complexity and space complexity of the algorithm is $O(2^n)$

\question{18.A}

A dynamic programming approach can be applied. To find the largest total combined length {\em TCL}, there are two cases. We define $L$ as the recorded length of a consecutive piece of wood. Assume $a_1, a_2, \dots , a_n$ is contained in an array $A$, which describes the marked segments of a piece of wood of length $n$. When $L+A[n] \le 5$, we take the large value of two
calculating methods of whether to cut $A[n]$ or not. When $L+A[n] > 5$, we just clear $L$ and recursion on the next value.

So define {\em TCL}$(A[1\dots n], L)$, where the index represents the length of the current piece of wood, we have 

\begin{equation*}
TCL(A[1\dots n], L) = 
  \begin{cases}
      max(A[n] + TCl(A[1\dots n-1],L+A[n]),\\    TCL(A[1\dots n-1],0)) & \mbox{if } L+A[n] \le 5 \\
      TCL(A[1\dots n-1],0) & \mbox{if } L+A[n] > 5
  \end{cases}
\end{equation*}
As we need to recurse the array for $n$ times, and there are only 5 possible values for calculation of $L$, the time complexity and space complexity of the algorithm is $O(5n)$, which is $O(n)$.

\question{18.B}

\question{18.C}

\end{document}
