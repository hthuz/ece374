\documentclass[12pt,a4paper]{article}
\usepackage{fullpage}
\pagestyle{plain}
% choose any of the following packages to support AmsTeX
%\usepackage{amsmath,amssymb,amsfonts,mathrsfs,mathptm,bm,mathtools}
% choose the following package to insert eps figures
% for png, jpg or pdf figures, use pdflatex
%\usepackage{graphicx}
\usepackage{amsmath}

%% Presenet code
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\newcommand{\question}[1]{\bigskip\noindent{\textbf{Q{#1} solution}}}

% set HW number
\newcommand{\HWnum}{5}
% specify first and last name and the ID number of students in the group
% append asterix to indicate who is making the submission
\newcommand{\StudentA}{Hanggang Zhu$^\ast$, 3200110457}
\newcommand{\StudentB}{Suhao Wang, 3200110777}
\newcommand{\StudentC}{Lumeng Xu 3200110184}

% ===============================================================
\begin{document}

%%% header
{\noindent \rule{\linewidth}{0.2mm}}\\
\noindent{ECE 374, ZJUI, Spring 2023\hfill%
  \textbf{\large H{}W\HWnum\ Solutions} \hfill \today\smallskip}

\noindent{\hfill \StudentA, \StudentB, and \StudentC \hfill}
\\[-0.2cm]{\noindent \rule{\linewidth}{0.2mm}}
%%% end header

% =============
\question{13.A}

In the naive Hanoi, disk n need to be moved from src to dest, with n - 1 disks in the tmp peg. But now it is forbidden to directly move disks move src to dest,the disk should be moved to tmp first and then moved to dest. So we need to move disks $n - 1$ to dest first (with intermediate begin on tmp peg), then move disk $n$ to tmp, move disks $n - 1$ from dest back to src(with intermediate being on tmp peg), move disk $n$ to dest and finally move disk $n -1 $ from src to dest again (with intermediate being on tmp peg). The correctness lies in that disk $n$ and disks $n - 1$ will be moved from src to dest, without violating rules.

The pseudo code is as follows:

\begin{lstlisting}
  Hanoi0(n, src, dest, tmp):
    if (n > 0) then
      Hanoi0(n - 1, src, dest, tmp)
      Move disk n from src to tmp
      Hanoi0(n - 1, dest, src, tmp)
      Move disk n from tmp to dest
      Hnaoi0(n - 1, src, dest, tmp)
\end{lstlisting}

The number of moves $T(n)$ can be represented as $T(n) = 3T(n - 1) + 2, n > 1$ with $T(1) = 2$. Solving the recurrence equation, we have $T(n) = 3^n - 1$

% =============

% =============
\question{13.B}
% =============

% =============
\question{13.C}

The largest remaining disk can be removed when nothing is on top of it. This is the same case in naive Hanoi when there's nothing on top largest remaining disk, we can move it to destination. So we can do modification to naive Hanoi with the difference that we remove the largest disk instead of moving it. The removed largest disk won't have any affect as in naive Hanoi the largest disk won't have any affect on rest of disks.

The pseudo code is as follows:
\begin{lstlisting}
  Hanoibyebye(n, src, dest, tmp, max_n):
    if (n > 0) then
      Hanoibyebye(n - 1, src, tmp, dest)
      if (n == max_n) then
        Remove disk n
      else
        Move disk n from src to tmp
      Hanoibyebye(n - 1, tmp, dest, src)
  
\end{lstlisting}

The number of moves $T(n)$ is the same as the case of naive Hanoi, where $T(n) = 2T(n - 1) + 1, n > 1$ with $T(1) = 1$. Solve the recurrence equation and there's $T(n) = 2^n - 1$. Upper bound is $O(2^n)$


% =============
\question{14.A}
% =============

% =============
\question{14.B}
% =============

\question{14.C}


\question{15.A}
\\We can use the Boyer-Moore Majority Vote Algorithm here. This algorithm works by maintaining a count of a candidate element that could be the majority element.
The count is incremented when an element is encountered that is equal to the candidate and decremented when it is not. If the count reaches zero, then a new candidate is chosen.
\\So, we can slove the problem according to the algorithm mentioned above:
\\Since strictly more than half of the birds belong to the same speicies, we can pick any two birds and put them in a cage together. If they are friendly to each other, then they 
are of the same species. We call this speices $S$. Otherwise, we can separate them and repeat the same step with two different birds. 
\\Now, we know that at least one bird belongs to $S$. We can use this bird as a reference and compare it with other birds by using the same process. We keep doing this until we
have compared the reference bird with every other bird. If more than half of the birds are friendly with the reference bird, then we say this bird belongs to the dominant species. 
We can output all the birds that are friendly with the reference bird. Then, we finish identifying every bird among the $n$ birds that belong to this dominant species.
\\As for the time complexity of this algorithm, in the worst case, we need to perform the experiment with all possible pairs of birds. There are $n$ choose 2 = $n(n-1)/2$ possible 
paris of birds, so the worst-case time complexity of this algorithm is $O(n^2)$.

\question{15.B}
\\For this question, we can use a variation of the Boyer-Moore Majority Vote Algorithm. Instead of looking for a majority element, we look for an element that occurs more that $n/p$ times,
where $p$ is the number of species present in the kettle of $n$ birds.
\\Suppose the plurality species has $k$ birds, where $k>n/2$. Then, we can pick any two birds and put them in a cage together. If they are friendly to each other, then they are of the same species.
We call this speices $S$. Otherwise, we can separate them and repeat the same step with two different birds. 
\\Now, we know that at least one bird belongs to $S$. We can use this bird as a reference and compare it with other birds by using the same process. We keep doing this until we have 
compared the reference bird with $k-1$ other birds. If more than half of the birds are friendly with the reference bird, then it belongs to the plurality species. We can output all the birds that 
are friendly with the reference bird. Then, we finish picking out the birds from the plurality species.
\\As for the time complexity of this algorithm, we only need to compare the reference bird with $k-1$ other birds, which is $O(k)$. Since $k>n/2$, the worst-case time complexity of this algorithm is
$O(n)$. This is more efficient than the above algorithm.

\end{document}
